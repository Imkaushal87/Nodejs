/*
üìò Node.js Modules, Globals & Object Destructuring ‚Äî NOTES

‚≠ê 1Ô∏è‚É£ require() in Node.js (Module Import)

require("./xyz.js"); // Importing one module into another

‚≠ê Important Points
‚Ä¢ require() executes the file immediately
‚Ä¢ It does NOT automatically share variables or functions
‚Ä¢ It returns module.exports

‚≠ê Used for
‚Ä¢ Configuration files
‚Ä¢ Logging
‚Ä¢ Database connections
‚Ä¢ Polyfills / side effects

‚≠ê 2Ô∏è‚É£ JavaScript Global Objects (Node.js vs Browser)

‚Ä¢ console.log(a + b); ‚Üí Prints sum of a and b
‚Ä¢ console.log("kuvar"); ‚Üí Prints a string

‚Ä¢ console.log(global); ‚Üí Node.js global object
‚Ä¢ console.log(window); ‚Üí Browser global object (‚ùå not in Node.js)
‚Ä¢ console.log(self); ‚Üí Browser / Web Worker global
‚Ä¢ console.log(frames); ‚Üí Browser-only
‚Ä¢ console.log(this); ‚Üí Top-level this (module.exports in Node.js)
‚Ä¢ console.log(globalThis); ‚Üí Universal global object

‚≠ê Key Notes
‚Ä¢ window, self, frames ‚ùå ‚Üí Browser only
‚Ä¢ global ‚úÖ ‚Üí Node.js only
‚Ä¢ globalThis ‚úÖ ‚Üí Works everywhere

‚≠ê In Node.js
‚Ä¢ globalThis === global ‚Üí true

‚≠ê 3Ô∏è‚É£ Object Destructuring in JavaScript

       

‚≠ê What is Object Destructuring?
‚Ä¢ Object destructuring allows extracting properties from an object into variables using concise syntax

‚≠ê Without Destructuring (Old Way)
   const user = {
             name: "Kuvar",
             age: 22,
             role: "Developer"
        };

         const name = user.name;
         const age = user.age;
         const role = user.role;

         console.log(name, age, role);

‚Ä¢ Access properties using dot notation
‚Ä¢ More lines of code
‚Ä¢ Less readable

‚≠ê With Object Destructuring (Modern Way)
 
       const user = {
          name: "Kuvar",
          age: 22,
          role: "Developer"
      };

      const { name, age, role } = user;

      console.log(name, age, role);

  
‚Ä¢ Extract values directly from object
‚Ä¢ Short and clean syntax

‚≠ê Benefits
‚Ä¢ Cleaner syntax
‚Ä¢ Less code
‚Ä¢ Better readability

‚≠ê 4Ô∏è‚É£ Node.js Module Scope (VERY IMPORTANT)

‚≠ê Core Rules
‚Ä¢ Every file is treated as a separate module
‚Ä¢ Variables and functions are private by default
‚Ä¢ Nothing leaks unless explicitly exported

‚≠ê This prevents global scope pollution

‚≠ê 5Ô∏è‚É£ app.js (Main File Explanation)

‚Ä¢ require("./xyz.js"); executes the file
‚Ä¢ require("./sum.js") returns exported object
‚Ä¢ Imported object contains only exported members

‚≠ê Why this works
‚Ä¢ sum.js explicitly exports calculateSum and x
‚Ä¢ require() returns the exported object
‚Ä¢ Access using dot notation ‚Üí obj.propertyName

‚≠ê 6Ô∏è‚É£ sum.js (Module File Explanation)

‚Ä¢ Top-level code executes immediately
‚Ä¢ Variables are module-private
‚Ä¢ Functions are scoped to the module

‚≠ê Exporting
‚Ä¢ module.exports is used to share data
‚Ä¢ Only exported values are accessible outside

‚≠ê 7Ô∏è‚É£ Common Mistakes (Avoid These ‚ùå)

‚ùå Creating global variables
‚Ä¢ sum = a + b; // BAD (creates global variable)

‚ùå Wrong export keyword
‚Ä¢ modules.exports = calculateSum; // ‚ùå wrong

‚úÖ Correct export
‚Ä¢ module.exports = calculateSum;

‚≠ê 8Ô∏è‚É£ Behind the Scenes (INTERVIEW GOLD ‚≠ê)

‚≠ê Node.js internally wraps every file like this:
‚Ä¢ (function (exports, require, module, __filename, __dirname) { ... })

‚≠ê That‚Äôs why
‚Ä¢ Variables don‚Äôt leak
‚Ä¢ this !== global
‚Ä¢ Modules are isolated

‚≠ê 9Ô∏è‚É£ One-Line Interview Answers

‚≠ê require() executes a module and returns module.exports
‚≠ê Node.js modules are isolated by default
‚≠ê Only exported values are accessible
‚≠ê globalThis is the standard global object
‚≠ê Object destructuring extracts object properties into variables


*?